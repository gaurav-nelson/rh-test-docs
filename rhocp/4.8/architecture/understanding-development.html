<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Understanding OpenShift Container Platform development :: Red Hat Docs</title>
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Red Hat Docs</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="rhocp" data-version="4.8">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Red Hat Openshift Container Platform</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">About</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../index.html">Welcome</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../learn_more_about_openshift.html">Learn more about OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../oke_about.html">About OpenShift Kubernetes Engine</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../legal-notice.html">Legal notice</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Release notes</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../release_notes/ocp-4-8-release-notes.html">OpenShift Container Platform 4.8 release notes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../release_notes/versioning-policy.html">Versioning policy</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Architectue</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architecture.html">Product architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architecture-installation.html">Installation and update</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="control-plane.html">The control plane</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="understanding-development.html">Understand OpenShift development</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architecture-rhcos.html">Red Hat Enterprise Linux CoreOS</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="admission-plug-ins.html">Admission plug-ins</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Red Hat Openshift Container Platform</span>
    <span class="version">4.8</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../rhel8/8/index.html">Red Hat Enterprise Linux</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../rhel8/8/index.html">8</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../index.html">Red Hat Openshift Container Platform</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">4.8</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Red Hat Openshift Container Platform</a></li>
    <li>Architectue</li>
    <li><a href="understanding-development.html">Understand OpenShift development</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///Users/ganelson/Documents/alt/openshift-docs/modules/architecture/pages/understanding-development.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Understanding OpenShift Container Platform development</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>To fully leverage the capability of containers when developing and running
enterprise-quality applications, ensure your environment is supported by tools
that allow containers to be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Created as discrete microservices that can be connected to other
containerized, and non-containerized, services. For example, you might want to
join your application with a database or attach a monitoring application to it.</p>
</li>
<li>
<p>Resilient, so if a server crashes or needs to go down for maintenance or to be
decommissioned, containers can start on another machine.</p>
</li>
<li>
<p>Automated to pick up code changes automatically and then start and deploy new
versions of themselves.</p>
</li>
<li>
<p>Scaled up, or replicated, to have more instances serving clients as demand
increases and then spun down to fewer instances as demand declines.</p>
</li>
<li>
<p>Run in different ways, depending on the type of application. For example, one
application might run once a month to produce a report and then exit. Another
application might need to run constantly and be highly available to clients.</p>
</li>
<li>
<p>Managed so you can watch the state of your application and react when
something goes wrong.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Containers’ widespread acceptance, and the resulting requirements for tools and
methods to make them enterprise-ready, resulted in many options for them.</p>
</div>
<div class="paragraph">
<p>The rest of this section explains options for
assets you can create when you build and deploy containerized Kubernetes
applications in OpenShift Container Platform. It also describes which approaches you might
use for different kinds of applications and development requirements.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="developing-containerized-applications"><a class="anchor" href="#developing-containerized-applications"></a>About developing containerized applications</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can approach application development with containers in many ways, and
different approaches might be more appropriate for different situations. To
illustrate some of this variety, the series of approaches that is presented
starts with developing a single container and ultimately deploys that container
as a mission-critical application for a large enterprise. These approaches
show different tools, formats, and methods that you can employ with containerized
application development. This topic describes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Building a simple container and storing it in a registry</p>
</li>
<li>
<p>Creating a Kubernetes manifest and saving it to a Git repository</p>
</li>
<li>
<p>Making an Operator to share your application with others</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="building-simple-container"><a class="anchor" href="#building-simple-container"></a>Building a simple container</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You have an idea for an application and you want to containerize it.</p>
</div>
<div class="paragraph">
<p>First you require a tool for building a container, like buildah or docker,
and a file that describes what goes in your container, which is typically a
<a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a>.</p>
</div>
<div class="paragraph">
<p>Next, you require a location to push the resulting container image so you can
pull it to run anywhere you want it to run. This location is a container
registry.</p>
</div>
<div class="paragraph">
<p>Some examples of each of these components are installed by default on most
Linux operating systems, except for the Dockerfile, which you provide yourself.</p>
</div>
<div class="paragraph">
<p>The following diagram displays the process of building and pushing an image:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/create-push-app.png" alt="Creating and pushing a containerized application">
</div>
<div class="title">Figure 1. Create a simple containerized application and push it to a registry</div>
</div>
<div class="paragraph">
<p>If you use a computer that runs Red Hat Enterprise Linux (RHEL) as the operating
system, the process of creating a containerized application requires the
following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Install container build tools: RHEL contains a set of tools that includes
podman, buildah, and skopeo that you use to build and manage containers.</p>
</li>
<li>
<p>Create a Dockerfile to combine base image and software: Information about
building your container goes into a file that is named <code>Dockerfile</code>. In that
file, you identify the base image you build from, the software packages you
install, and the software you copy into the container. You also identify
parameter values like network ports that you expose outside the container and
volumes that you mount inside the container. Put your Dockerfile and the
software you want to containerize in a directory on your RHEL system.</p>
</li>
<li>
<p>Run buildah or docker build: Run the <code>buildah build-using-dockerfile</code> or
the <code>docker build</code> command to pull your chosen base image to the local system and
create a container image that is stored locally. You can also build container images
without a Dockerfile by using buildah.</p>
</li>
<li>
<p>Tag and push to a registry: Add a tag to your new container image that
identifies the location of the registry in which you want to store and share
your container. Then push that image to the registry by running the
<code>podman push</code> or <code>docker push</code> command.</p>
</li>
<li>
<p>Pull and run the image: From any system that has a container client tool,
such as podman or docker, run a command that identifies your new image.
For example, run the <code>podman run &lt;image_name&gt;</code> or <code>docker run &lt;image_name&gt;</code>
command. Here <code>&lt;image_name&gt;</code> is the name of your new container image, which
resembles <code>quay.io/myrepo/myapp:latest</code>. The registry might require credentials
to push and pull images.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="container-build-tool-options"><a class="anchor" href="#container-build-tool-options"></a>Container build tool options</h3>
<div class="paragraph">
<p>While the Docker Container Engine and <code>docker</code> command are popular tools
to work with containers, with RHEL and many other Linux systems, you can
instead choose a different set of container tools that includes podman, skopeo,
and buildah. You can still use Docker Container Engine tools to create
containers that will run in OpenShift Container Platform and any other container platform.</p>
</div>
<div class="paragraph">
<p>Building and managing containers with buildah, podman, and skopeo results in
industry standard container images that include features tuned specifically
for ultimately deploying those containers in OpenShift Container Platform or other Kubernetes
environments. These tools are daemonless and can be run without root privileges,
so there is less overhead in running them.</p>
</div>
<div class="paragraph">
<p>When you ultimately run your containers in OpenShift Container Platform, you use the
<a href="https://cri-o.io/">CRI-O</a> container engine. CRI-O runs on every worker and
control plane machine (also known as the master machine) in an OpenShift Container Platform cluster, but CRI-O is not yet supported as
a standalone runtime outside of OpenShift Container Platform.</p>
</div>
</div>
<div class="sect2">
<h3 id="base-image-options"><a class="anchor" href="#base-image-options"></a>Base image options</h3>
<div class="paragraph">
<p>The base image you choose to build your application on contains a set of
software that resembles a Linux system to your application. When you build your
own image, your software is placed into that file system and sees that file
system as though it were looking at its operating system. Choosing this base
image has major impact on how secure, efficient and upgradeable your container
is in the future.</p>
</div>
<div class="paragraph">
<p>Red Hat provides a new set of base images referred to as
<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html-single/getting_started_with_containers/index#using_red_hat_base_container_images_standard_and_minimal">Red Hat Universal Base Images</a> (UBI).
These images are based on Red Hat Enterprise Linux and are similar to base
images that Red Hat has offered in the past, with one major difference: they
are freely redistributable without a Red Hat subscription. As a result, you can
build your application on UBI images without having to worry about how they
are shared or the need to create different images for different environments.</p>
</div>
<div class="paragraph">
<p>These UBI images have standard, init, and minimal versions. You can also use the
<a href="https://access.redhat.com/documentation/en-us/red_hat_software_collections/3/html-single/using_red_hat_software_collections_container_images/index">Red Hat Software Collections</a>
images as a foundation for applications that rely on specific runtime
environments such as Node.js, Perl, or Python. Special versions of some of
these runtime base images are referred to as Source-to-Image (S2I) images. With
S2I images, you can insert your code into a base image environment that is ready
to run that code.</p>
</div>
<div class="paragraph">
<p>S2I images are available for you to use directly from the OpenShift Container Platform web UI
by selecting <strong>Catalog</strong> &#8594; <strong>Developer Catalog</strong>, as shown in the following figure:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/developer-catalog.png" alt="OpenShift Container Platform Developer Catalog">
</div>
<div class="title">Figure 2. Choose S2I base images for apps that need specific runtimes</div>
</div>
</div>
<div class="sect2">
<h3 id="understanding-development-registry-options"><a class="anchor" href="#understanding-development-registry-options"></a>Registry options</h3>
<div class="paragraph">
<p>Container registries are where you store container images so you can share them
with others and make them available to the platform where they ultimately run.
You can select large, public container registries that offer free accounts or a
premium version that offer more storage and special features. You can also
install your own registry that can be exclusive to your organization or
selectively shared with others.</p>
</div>
<div class="paragraph">
<p>To get Red Hat images and certified partner images, you can draw from the
Red Hat Registry. The Red Hat Registry is represented by two locations:
<code>registry.access.redhat.com</code>, which is unauthenticated and deprecated, and
<code>registry.redhat.io</code>, which requires authentication. You can learn about the Red
Hat and partner images in the Red Hat Registry from the
<a href="https://catalog.redhat.com/software/containers/explore">Container images section of the Red Hat Ecosystem Catalog</a>.
Besides listing Red Hat container images, it also shows extensive information
about the contents and quality of those images, including health scores that are
based on applied security updates.</p>
</div>
<div class="paragraph">
<p>Large, public registries include <a href="https://hub.docker.com/">Docker Hub</a> and
<a href="https://quay.io/">Quay.io</a>. The Quay.io registry is owned and managed by Red
Hat. Many of the components used in OpenShift Container Platform are stored in Quay.io,
including container images and the Operators that are used to deploy
OpenShift Container Platform itself. Quay.io also offers the means of storing other types of
content, including Helm charts.</p>
</div>
<div class="paragraph">
<p>If you want your own, private container registry, OpenShift Container Platform itself
includes a private container registry that is installed with OpenShift Container Platform
and runs on its cluster. Red Hat also offers a private version of the Quay.io
registry called <a href="https://access.redhat.com/products/red-hat-quay">Red Hat Quay</a>.
Red Hat Quay includes geo replication, Git build triggers, Clair image scanning,
and many other features.</p>
</div>
<div class="paragraph">
<p>All of the registries mentioned here can require credentials to download images
from those registries. Some of those credentials are presented on a cluster-wide
basis from OpenShift Container Platform, while other credentials can be assigned to individuals.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-kubernetes-manifest-openshift"><a class="anchor" href="#creating-kubernetes-manifest-openshift"></a>Creating a Kubernetes manifest for OpenShift Container Platform</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While the container image is the basic building block for a containerized
application, more information is required to manage and deploy that application
in a Kubernetes environment such as OpenShift Container Platform. The typical next steps after
you create an image are to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Understand the different resources you work with in Kubernetes manifests</p>
</li>
<li>
<p>Make some decisions about what kind of an application you are running</p>
</li>
<li>
<p>Gather supporting components</p>
</li>
<li>
<p>Create a manifest and store that manifest in a Git repository so you can store
it in a source versioning system, audit it, track it, promote and deploy it
to the next environment, roll it back to earlier versions, if necessary, and
share it with others</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="understanding-kubernetes-pods"><a class="anchor" href="#understanding-kubernetes-pods"></a>About Kubernetes pods and services</h3>
<div class="paragraph">
<p>While the container image is the basic unit with docker, the basic units that
Kubernetes works with are called
<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">pods</a>.
Pods represent the next step in building out an application. A pod can contain
one or more than one container. The key is that the pod is the single unit
that you deploy, scale, and manage.</p>
</div>
<div class="paragraph">
<p>Scalability and namespaces are probably the main items to consider when determining
what goes in a pod. For ease of deployment, you might want to deploy a container
in a pod and include its own logging and monitoring container in the pod. Later,
when you run the pod and need to scale up an additional instance, those other
containers are scaled up with it. For namespaces, containers in a pod share the
same network interfaces, shared storage volumes, and resource limitations,
such as memory and CPU, which makes it easier to manage the contents of the pod
as a single unit. Containers in a pod can also communicate with each other by
using standard inter-process communications, such as System V semaphores or
POSIX shared memory.</p>
</div>
<div class="paragraph">
<p>While individual pods represent a scalable unit in Kubernetes, a
<a href="https://kubernetes.io/docs/concepts/services-networking/service/">service</a>
provides a means of grouping together a set of pods to create a complete, stable
application that can complete tasks such as load balancing. A service is also
more permanent than a pod because the service remains available from the same
IP address until you delete it. When the service is in use, it is requested by
name and the OpenShift Container Platform cluster resolves that name into the IP addresses
and ports where you can reach the pods that compose the service.</p>
</div>
<div class="paragraph">
<p>By their nature, containerized applications are separated from the operating
systems where they run and, by extension, their users. Part of your Kubernetes
manifest describes how to expose the application to internal and external
networks by defining
<a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">network policies</a>
that allow fine-grained control over communication with your containerized
applications. To connect incoming requests for HTTP, HTTPS, and other services
from outside your cluster to services inside your cluster, you can use an
<a href="https://kubernetes.io/docs/concepts/services-networking/ingress/"><code>Ingress</code></a>
resource.</p>
</div>
<div class="paragraph">
<p>If your container requires on-disk storage instead of database storage, which
might be provided through a service, you can add
<a href="https://kubernetes.io/docs/concepts/storage/volumes/">volumes</a>
to your manifests to make that storage available to your pods. You can configure
the manifests to create persistent volumes (PVs) or dynamically create volumes that
are added to your <code>Pod</code> definitions.</p>
</div>
<div class="paragraph">
<p>After you define a group of pods that compose your application, you can define
those pods in
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"><code>Deployment</code></a>
and <a href="#../applications/deployments/what-deployments-are.adoc#what-deployments-are" class="page unresolved"><code>DeploymentConfig</code></a> objects.</p>
</div>
</div>
<div class="sect2">
<h3 id="application-types"><a class="anchor" href="#application-types"></a>Application types</h3>
<div class="paragraph">
<p>Next, consider how your application type influences how to run it.</p>
</div>
<div class="paragraph">
<p>Kubernetes defines different types of workloads that are appropriate for
different kinds of applications. To determine the appropriate workload for your
application, consider if the application is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Meant to run to completion and be done. An example is an application that
starts up to produce a report and exits when the report is complete. The
application might not run again then for a month. Suitable OpenShift Container Platform
objects for these types of applications include
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/"><code>Job</code></a>
and <a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/"><code>CronJob</code></a> objects.</p>
</li>
<li>
<p>Expected to run continuously. For long-running applications, you can write a
<a href="#../applications/deployments/what-deployments-are.adoc#deployments-kube-deployments" class="page unresolved">deployment</a>.</p>
</li>
<li>
<p>Required to be highly available. If your application requires high
availability, then you want to size your deployment to have more than one
instance. A <code>Deployment</code> or <code>DeploymentConfig</code> object can incorporate a
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">replica set</a>
for that type of application. With replica sets, pods run across multiple nodes
to make sure the application is always available, even if a worker goes down.</p>
</li>
<li>
<p>Need to run on every node. Some types of Kubernetes applications are intended
to run in the cluster itself on every master or worker node. DNS and monitoring
applications are examples of applications that need to run continuously on every
node. You can run this type of application as a
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">daemon set</a>.
You can also run a daemon set on a subset of nodes, based on node labels.</p>
</li>
<li>
<p>Require life-cycle management. When you want to hand off your application so
that others can use it, consider creating an
<a href="https://www.openshift.com/learn/topics/operators">Operator</a>. Operators let you build in
intelligence, so it can handle things like backups and upgrades automatically.
Coupled with the Operator Lifecycle Manager (OLM), cluster managers can expose
Operators to selected namespaces so that users in the cluster can run them.</p>
</li>
<li>
<p>Have identity or numbering requirements. An application might have identity
requirements or numbering requirements. For example, you might be
required to run exactly three instances of the application and to name the
instances <code>0</code>, <code>1</code>, and <code>2</code>. A
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">stateful set</a>
is suitable for this application. Stateful sets are most useful for applications
that require independent storage, such as databases and zookeeper clusters.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="supporting-components"><a class="anchor" href="#supporting-components"></a>Available supporting components</h3>
<div class="paragraph">
<p>The application you write might need supporting components, like a database or
a logging component. To fulfill that need, you might be able to obtain the
required component from the following Catalogs that are available in the
OpenShift Container Platform web console:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OperatorHub, which is available in each OpenShift Container Platform 4.8
cluster. The OperatorHub makes Operators available from Red Hat,
certified Red Hat partners, and community members to the cluster operator. The
cluster operator can make those Operators available in all or selected
namespaces in the cluster, so developers can launch them and configure them
with their applications.</p>
</li>
<li>
<p>Templates, which are useful for a one-off type of application, where the
lifecycle of a component is not important after it is installed. A template provides an easy
way to get started developing a Kubernetes application with minimal overhead.
A template can be a list of resource definitions, which could be <code>Deployment</code>,
<code>Service</code>, <code>Route</code>, or other objects. If you want to change names or resources,
you can set these values as parameters in the template.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can configure the supporting Operators and
templates to the specific needs of your development team and then make them
available in the namespaces in which your developers work. Many people add
shared templates to the <code>openshift</code> namespace because it is accessible from all
other namespaces.</p>
</div>
</div>
<div class="sect2">
<h3 id="applying-manifest"><a class="anchor" href="#applying-manifest"></a>Applying the manifest</h3>
<div class="paragraph">
<p>Kubernetes manifests let you create a more complete picture of the components
that make up your Kubernetes applications. You write these manifests as YAML
files and deploy them by applying them to the cluster, for example, by running
the <code>oc apply</code> command.</p>
</div>
</div>
<div class="sect2">
<h3 id="manifest-next-steps"><a class="anchor" href="#manifest-next-steps"></a>Next steps</h3>
<div class="paragraph">
<p>At this point, consider ways to automate your container development process.
Ideally, you have some sort of CI pipeline that builds the images and pushes
them to a registry. In particular, a GitOps pipeline integrates your container
development with the Git repositories that you use to store the software that
is required to build your applications.</p>
</div>
<div class="paragraph">
<p>The workflow to this point might look like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Day 1: You write some YAML. You then run the <code>oc apply</code> command to apply that
YAML to the cluster and test that it works.</p>
</li>
<li>
<p>Day 2: You put your YAML container configuration file into your own Git
repository. From there, people who want to install that app, or help you improve
it, can pull down the YAML and apply it to their cluster to run the app.</p>
</li>
<li>
<p>Day 3: Consider writing an Operator for your application.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="develop-for-operators"><a class="anchor" href="#develop-for-operators"></a>Develop for Operators</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Packaging and deploying your application as an Operator might be preferred
if you make your application available for others to run. As noted earlier,
Operators add a lifecycle component to your application that acknowledges that
the job of running an application is not complete as soon as it is installed.</p>
</div>
<div class="paragraph">
<p>When you create an application as an Operator, you can build in your own
knowledge of how to run and maintain the application. You can build in features
for upgrading the application, backing it up, scaling it, or keeping track of
its state. If you configure the application correctly, maintenance tasks,
like updating the Operator, can happen automatically and invisibly to the
Operator&#8217;s users.</p>
</div>
<div class="paragraph">
<p>An example of a useful Operator is one that is set up to automatically back up
data at particular times. Having an Operator manage an application&#8217;s backup at
set times can save a system administrator from remembering to do it.</p>
</div>
<div class="paragraph">
<p>Any application maintenance that has traditionally been completed manually,
like backing up data or rotating certificates, can be completed automatically
with an Operator.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
