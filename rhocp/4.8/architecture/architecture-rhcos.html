<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Red Hat Enterprise Linux CoreOS (RHCOS) :: Red Hat Docs</title>
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Red Hat Docs</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="rhocp" data-version="4.8">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Red Hat Openshift Container Platform</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">About</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../index.html">Welcome</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../learn_more_about_openshift.html">Learn more about OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../oke_about.html">About OpenShift Kubernetes Engine</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../legal-notice.html">Legal notice</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Release notes</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../release_notes/ocp-4-8-release-notes.html">OpenShift Container Platform 4.8 release notes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../release_notes/versioning-policy.html">Versioning policy</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Architectue</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architecture.html">Product architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architecture-installation.html">Installation and update</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="control-plane.html">The control plane</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="understanding-development.html">Understand OpenShift development</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="architecture-rhcos.html">Red Hat Enterprise Linux CoreOS</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="admission-plug-ins.html">Admission plug-ins</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Red Hat Openshift Container Platform</span>
    <span class="version">4.8</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Red Hat Openshift Container Platform</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">4.8</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Red Hat Openshift Container Platform</a></li>
    <li>Architectue</li>
    <li><a href="architecture-rhcos.html">Red Hat Enterprise Linux CoreOS</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///Users/ganelson/Documents/alt/openshift-docs/modules/architecture/pages/architecture-rhcos.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Red Hat Enterprise Linux CoreOS (RHCOS)</h1>
<div class="sect1">
<h2 id="rhcos-about_architecture-rhcos"><a class="anchor" href="#rhcos-about_architecture-rhcos"></a>About RHCOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Red Hat Enterprise Linux CoreOS (RHCOS) represents the next generation of single-purpose container operating system technology. Created by the same development teams that created Red Hat Enterprise Linux Atomic Host and CoreOS Container Linux, RHCOS combines the quality standards of Red Hat Enterprise Linux (RHEL) with the automated, remote upgrade features from Container Linux.</p>
</div>
<div class="paragraph">
<p>RHCOS is supported only as a component of OpenShift Container Platform 4.8 for all OpenShift Container Platform machines. RHCOS is the only supported operating system for OpenShift Container Platform control plane, or master, machines. While RHCOS is the default operating system for all cluster machines, you can create compute machines, which are also known as worker machines, that use RHEL as their operating system. There are two general ways RHCOS is deployed in OpenShift Container Platform 4.8:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you install your cluster on infrastructure that the cluster provisions, RHCOS images are downloaded to the target platform during installation, and suitable Ignition config files, which control the RHCOS configuration, are used to deploy the machines.</p>
</li>
<li>
<p>If you install your cluster on infrastructure that you manage, you must follow the installation documentation to obtain the RHCOS images, generate Ignition config files, and use the Ignition config files to provision your machines.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="rhcos-key-features_architecture-rhcos"><a class="anchor" href="#rhcos-key-features_architecture-rhcos"></a>Key RHCOS features</h3>
<div class="paragraph">
<p>The following list describes key features of the RHCOS operating system:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Based on RHEL</strong>: The underlying operating system consists primarily of RHEL components. The same quality, security, and control measures that support RHEL also support RHCOS. For example, RHCOS software is in RPM packages, and each RHCOS system starts up with a RHEL kernel and a set of services that are managed by the systemd init system.</p>
</li>
<li>
<p><strong>Controlled immutability</strong>: Although it contains RHEL components, RHCOS is designed to be managed more tightly than a default RHEL installation. Management is performed remotely from the OpenShift Container Platform cluster. When you set up your RHCOS machines, you can modify only a few system settings. This controlled immutability allows OpenShift Container Platform to store the latest state of RHCOS systems in the cluster so it is always able to create additional machines and perform updates based on the latest RHCOS configurations.</p>
</li>
<li>
<p><strong>CRI-O container runtime</strong>: Although RHCOS contains features for running the OCI- and libcontainer-formatted containers that Docker requires, it incorporates the CRI-O container engine instead of the Docker container engine. By focusing on features needed by Kubernetes platforms, such as OpenShift Container Platform, CRI-O can offer specific compatibility with different Kubernetes versions. CRI-O also offers a smaller footprint and reduced attack surface than is possible with container engines that offer a larger feature set. At the moment, CRI-O is the only engine available within OpenShift Container Platform clusters.</p>
</li>
<li>
<p><strong>Set of container tools</strong>: For tasks such as building, copying, and otherwise managing containers, RHCOS replaces the Docker CLI tool with a compatible set of container tools. The podman CLI tool supports many container runtime features, such as running, starting, stopping, listing, and removing containers and container images. The skopeo CLI tool can copy, authenticate, and sign images. You can use the <code>crictl</code> CLI tool to work with containers and pods from the CRI-O container engine. While direct use of these tools in RHCOS is discouraged, you can use them for debugging purposes.</p>
</li>
<li>
<p><strong>rpm-ostree upgrades</strong>: RHCOS features transactional upgrades using the <code>rpm-ostree</code> system. Updates are delivered by means of container images and are part of the OpenShift Container Platform update process. When deployed, the container image is pulled, extracted, and written to disk, then the bootloader is modified to boot into the new version. The machine will reboot into the update in a rolling manner to ensure cluster capacity is minimally impacted.</p>
</li>
<li>
<p><strong>bootupd firmware and bootloader updater</strong>: Package managers and hybrid systems such as <code>rpm-ostree</code> do not update the firmware or the bootloader. With <code>bootupd</code>, RHCOS users have access to a cross-distribution, system-agnostic update tool that manages firmware and boot updates in UEFI and legacy BIOS boot modes that run on modern architectures, such as x86_64, ppc64le, and aarch64.</p>
<div class="paragraph">
<p>For information about how to install <code>bootupd</code>, see the documentation for <em>Updating the bootloader using bootupd</em> for more information.</p>
</div>
</li>
<li>
<p><strong>Updated through the Machine Config Operator</strong>: In OpenShift Container Platform, the Machine Config Operator handles operating system upgrades. Instead of upgrading individual packages, as is done with <code>yum</code> upgrades, <code>rpm-ostree</code> delivers upgrades of the OS as an atomic unit. The new OS deployment is staged during upgrades and goes into effect on the next reboot. If something goes wrong with the upgrade, a single rollback and reboot returns the system to the previous state. RHCOS upgrades in OpenShift Container Platform are performed during cluster updates.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For RHCOS systems, the layout of the <code>rpm-ostree</code> file system has the following characteristics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/usr</code> is where the operating system binaries and libraries are stored and is read-only. We do not support altering this.</p>
</li>
<li>
<p><code>/etc</code>, <code>/boot</code>, <code>/var</code> are writable on the system but only intended to be altered by the Machine Config Operator.</p>
</li>
<li>
<p><code>/var/lib/containers</code> is the graph storage location for storing container images.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="rhcos-configured_architecture-rhcos"><a class="anchor" href="#rhcos-configured_architecture-rhcos"></a>Choosing how to configure RHCOS</h3>
<div class="paragraph">
<p>RHCOS is designed to deploy on an OpenShift Container Platform cluster with a minimal amount of user configuration. In its most basic form, this consists of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Starting with a provisioned infrastructure, such as on AWS, or provisioning the infrastructure yourself.</p>
</li>
<li>
<p>Supplying a few pieces of information, such as credentials and cluster name, in an <code>install-config.yaml</code> file when running <code>openshift-install</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Because RHCOS systems in OpenShift Container Platform are designed to be fully managed from the OpenShift Container Platform cluster after that, directly changing an RHCOS machine is discouraged. Although limited direct access to RHCOS machines cluster can be accomplished for debugging purposes, you should not directly configure RHCOS systems. Instead, if you need to add or change features on your OpenShift Container Platform nodes, consider making changes in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Kubernetes workload objects, such as DaemonSet and Deployment</strong>: If you need to add services or other user-level features to your cluster, consider adding them as Kubernetes workload objects. Keeping those features outside of specific node configurations is the best way to reduce the risk of breaking the cluster on subsequent upgrades.</p>
</li>
<li>
<p><strong>Day-2 customizations</strong>: If possible, bring up a cluster without making any customizations to cluster nodes and make necessary node changes after the cluster is up. Those changes are easier to track later and less likely to break updates. Creating machine configs or modifying Operator custom resources are ways of making these customizations.</p>
</li>
<li>
<p><strong>Day-1 customizations</strong>: For customizations that you must implement when the cluster first comes up, there are ways of modifying your cluster so changes are implemented on first boot.
Day-1 customizations can be done through Ignition configs and manifest files during <code>openshift-install</code> or by adding boot options during ISO installs provisioned by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here are examples of customizations you could do on day 1:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Kernel arguments</strong>: If particular kernel features or tuning is needed on nodes when the cluster first boots.</p>
</li>
<li>
<p><strong>Disk encryption</strong>: If your security needs require that the root file system on the nodes are encrypted, such as with FIPS support.</p>
</li>
<li>
<p><strong>Kernel modules</strong>: If a particular hardware device, such as a network card or video card, does not have a usable module available by default in the Linux kernel.</p>
</li>
<li>
<p><strong>Chronyd</strong>: If you want to provide specific clock settings to your nodes, such as the location of time servers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To accomplish these tasks, you can augment the <code>openshift-install</code> process to include additional objects such as <code>MachineConfig</code> objects. Those procedures that result in creating machine configs can be passed to the Machine Config Operator after the cluster is up.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Ignition config files that the installation program generates contain certificates that expire after 24 hours, which are then renewed at that time. If the cluster is shut down before renewing the certificates and the cluster is later restarted after the 24 hours have elapsed, the cluster automatically recovers the expired certificates. The exception is that you must manually approve the pending <code>node-bootstrapper</code> certificate signing requests (CSRs) to recover kubelet certificates. See the documentation for <em>Recovering from expired control plane certificates</em> for more information.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="rhcos-deployed_architecture-rhcos"><a class="anchor" href="#rhcos-deployed_architecture-rhcos"></a>Choosing how to deploy RHCOS</h3>
<div class="paragraph">
<p>Differences between RHCOS installations for OpenShift Container Platform are based on whether you are deploying on an infrastructure provisioned by the installer or by the user:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Installer-provisioned</strong>: Some cloud environments offer pre-configured infrastructures that allow you to bring up an OpenShift Container Platform cluster with minimal configuration. For these types of installations, you can supply Ignition configs that place content on each node so it is there when the cluster first boots.</p>
</li>
<li>
<p><strong>User-provisioned</strong>: If you are provisioning your own infrastructure, you have more flexibility in how you add content to a RHCOS node. For example, you could add kernel arguments when you boot the RHCOS ISO installer to install each system. However, in most cases where configuration is required on the operating system itself, it is best to provide that configuration through an Ignition config.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Ignition facility runs only when the RHCOS system is first set up. After that, Ignition configs can be supplied later using the machine config.</p>
</div>
</div>
<div class="sect2">
<h3 id="rhcos-about-ignition_architecture-rhcos"><a class="anchor" href="#rhcos-about-ignition_architecture-rhcos"></a>About Ignition</h3>
<div class="paragraph">
<p>Ignition is the utility that is used by RHCOS to manipulate disks during initial configuration. It completes common disk tasks, including partitioning disks, formatting partitions, writing files, and configuring users. On first boot, Ignition reads its configuration from the installation media or the location that you specify and applies the configuration to the machines.</p>
</div>
<div class="paragraph">
<p>Whether you are installing your cluster or adding machines to it, Ignition always performs the initial configuration of the OpenShift Container Platform cluster machines. Most of the actual system setup happens on each machine itself. For each machine, Ignition takes the RHCOS image and boots the RHCOS kernel. Options on the kernel command line identify the type of deployment and the location of the Ignition-enabled initial RAM disk (initramfs).</p>
</div>
<div class="sect3">
<h4 id="about-ignition_architecture-rhcos"><a class="anchor" href="#about-ignition_architecture-rhcos"></a>How Ignition works</h4>
<div class="paragraph">
<p>To create machines by using Ignition, you need Ignition config files. The OpenShift Container Platform installation program creates the Ignition config files that you need to deploy your cluster. These files are based on the information that you provide to the installation program directly or through an <code>install-config.yaml</code> file.</p>
</div>
<div class="paragraph">
<p>The way that Ignition configures machines is similar to how tools like <a href="https://cloud-init.io/">cloud-init</a> or Linux Anaconda <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html-single/installation_guide/index#chap-kickstart-installations">kickstart</a> configure systems, but with some important differences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ignition runs from an initial RAM disk that is separate from the system you are installing to. Because of that, Ignition can repartition disks, set up file systems, and perform other changes to the machine&#8217;s permanent file system. In contrast, cloud-init runs as part of a machine init system when the system boots, so making foundational changes to things like disk partitions cannot be done as easily. With cloud-init, it is also difficult to reconfigure the boot process while you are in the middle of the node boot process.</p>
</li>
<li>
<p>Ignition is meant to initialize systems, not change existing systems. After a machine initializes and the kernel is running from the installed system, the Machine Config Operator from the OpenShift Container Platform cluster completes all future machine configuration.</p>
</li>
<li>
<p>Instead of completing a defined set of actions, Ignition implements a declarative configuration. It checks that all partitions, files, services, and other items are in place before the new machine starts. It then makes the changes, like copying files to disk that are necessary for the new machine to meet the specified configuration.</p>
</li>
<li>
<p>After Ignition finishes configuring a machine, the kernel keeps running but discards the initial RAM disk and pivots to the installed system on disk. All of the new system services and other features start without requiring a system reboot.</p>
</li>
<li>
<p>Because Ignition confirms that all new machines meet the declared configuration, you cannot have a partially configured machine. If a machine setup fails, the initialization process does not finish, and Ignition does not start the new machine. Your cluster will never contain partially configured machines. If Ignition cannot complete, the machine is not added to the cluster. You must add a new machine instead. This behavior prevents the difficult case of debugging a machine when the results of a failed configuration task are not known until something that depended on it fails at a later date.</p>
</li>
<li>
<p>If there is a problem with an Ignition config that causes the setup of a machine to fail, Ignition will not try to use the same config to set up another machine. For example, a failure could result from an Ignition config made up of a parent and child config that both want to create the same file. A failure in such a case would prevent that Ignition config from being used again to set up an other machines until the problem is resolved.</p>
</li>
<li>
<p>If you have multiple Ignition config files, you get a union of that set of configs. Because Ignition is declarative, conflicts between the configs could cause Ignition to fail to set up the machine. The order of information in those files does not matter. Ignition will sort and implement each setting in ways that make the most sense. For example, if a file needs a directory several levels deep, if another file needs a directory along that path, the later file is created first. Ignition sorts and creates all files, directories, and links by depth.</p>
</li>
<li>
<p>Because Ignition can start with a completely empty hard disk, it can do something cloud-init cannot do: set up systems on bare metal from scratch using features such as PXE boot. In the bare metal case, the Ignition config is injected into the boot partition so that Ignition can find it and configure the system correctly.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="ignition-sequence_architecture-rhcos"><a class="anchor" href="#ignition-sequence_architecture-rhcos"></a>The Ignition sequence</h4>
<div class="paragraph">
<p>The Ignition process for an RHCOS machine in an OpenShift Container Platform cluster involves the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The machine gets its Ignition config file. Control plane machines (also known as the master machines) get their Ignition config files from the bootstrap machine, and worker machines get Ignition config files from a master.</p>
</li>
<li>
<p>Ignition creates disk partitions, file systems, directories, and links on the machine. It supports RAID arrays but does not support LVM volumes.</p>
</li>
<li>
<p>Ignition mounts the root of the permanent file system to the <code>/sysroot</code> directory in the initramfs and starts working in that <code>/sysroot</code> directory.</p>
</li>
<li>
<p>Ignition configures all defined file systems and sets them up to mount appropriately at runtime.</p>
</li>
<li>
<p>Ignition runs <code>systemd</code> temporary files to populate required files in the <code>/var</code> directory.</p>
</li>
<li>
<p>Ignition runs the Ignition config files to set up users, systemd unit files, and other configuration files.</p>
</li>
<li>
<p>Ignition unmounts all components in the permanent system that were mounted in the initramfs.</p>
</li>
<li>
<p>Ignition starts up the init process of the new machine, which in turn starts up all other services on the machine that run during system boot.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At the end of this process, the machine is ready to join the cluster and does not require a reboot.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ignition-config-viewing_architecture-rhcos"><a class="anchor" href="#ignition-config-viewing_architecture-rhcos"></a>Viewing Ignition configuration files</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To see the Ignition config file used to deploy the bootstrap machine, run the
following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-terminal hljs" data-lang="terminal">$ openshift-install create ignition-configs --dir $HOME/testconfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>After you answer a few questions, the <code>bootstrap.ign</code>, <code>master.ign</code>, and
<code>worker.ign</code> files appear in the directory you entered.</p>
</div>
<div class="paragraph">
<p>To see the contents of the <code>bootstrap.ign</code> file, pipe it through the <code>jq</code> filter.
Here&#8217;s a snippet from that file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-terminal hljs" data-lang="terminal">$ cat $HOME/testconfig/bootstrap.ign | jq
{
  "ignition": {
    "version": "3.2.0"
  },
  "passwd": {
    "users": [
      {
        "name": "core",
        "sshAuthorizedKeys": [
          "ssh-rsa AAAAB3NzaC1yc...."
        ]
      }
    ]
  },
  "storage": {
    "files": [
      {
        "overwrite": false,
        "path": "/etc/motd",
        "user": {
          "name": "root"
        },
        "append": [
          {
            "source": "data:text/plain;charset=utf-8;base64,VGhpcyBpcyB0aGUgYm9vdHN0cmFwIG5vZGU7IGl0IHdpbGwgYmUgZGVzdHJveWVkIHdoZW4gdGhlIG1hc3RlciBpcyBmdWxseSB1cC4KClRoZSBwcmltYXJ5IHNlcnZpY2VzIGFyZSByZWxlYXNlLWltYWdlLnNlcnZpY2UgZm9sbG93ZWQgYnkgYm9vdGt1YmUuc2VydmljZS4gVG8gd2F0Y2ggdGhlaXIgc3RhdHVzLCBydW4gZS5nLgoKICBqb3VybmFsY3RsIC1iIC1mIC11IHJlbGVhc2UtaW1hZ2Uuc2VydmljZSAtdSBib290a3ViZS5zZXJ2aWNlCg=="
          }
        ],
        "mode": 420
      },
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>To decode the contents of a file listed in the <code>bootstrap.ign</code> file, pipe the
base64-encoded data string representing the contents of that file to the <code>base64
-d</code> command. Here&#8217;s an example using the contents of the <code>/etc/motd</code> file added to
the bootstrap machine from the output shown above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-terminal hljs" data-lang="terminal">$ echo VGhpcyBpcyB0aGUgYm9vdHN0cmFwIG5vZGU7IGl0IHdpbGwgYmUgZGVzdHJveWVkIHdoZW4gdGhlIG1hc3RlciBpcyBmdWxseSB1cC4KClRoZSBwcmltYXJ5IHNlcnZpY2VzIGFyZSByZWxlYXNlLWltYWdlLnNlcnZpY2UgZm9sbG93ZWQgYnkgYm9vdGt1YmUuc2VydmljZS4gVG8gd2F0Y2ggdGhlaXIgc3RhdHVzLCBydW4gZS5nLgoKICBqb3VybmFsY3RsIC1iIC1mIC11IHJlbGVhc2UtaW1hZ2Uuc2VydmljZSAtdSBib290a3ViZS5zZXJ2aWNlCg== | base64 --decode</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example output</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-terminal hljs" data-lang="terminal">This is the bootstrap node; it will be destroyed when the master is fully up.

The primary services are release-image.service followed by bootkube.service. To watch their status, run e.g.

  journalctl -b -f -u release-image.service -u bootkube.service</code></pre>
</div>
</div>
<div class="paragraph">
<p>Repeat those commands on the <code>master.ign</code> and <code>worker.ign</code> files to see the source
of Ignition config files for each of those machine types.  You should see a line
like the following for the <code>worker.ign</code>, identifying how it gets its Ignition
config from the bootstrap machine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-terminal hljs" data-lang="terminal">"source": "https://api.myign.develcluster.example.com:22623/config/worker",</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here are a few things you can learn from the <code>bootstrap.ign</code> file:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Format: The format of the file is defined in the
<a href="https://coreos.github.io/ignition/configuration-v3_2/">Ignition config spec</a>.
Files of the same format are used later by the MCO to merge changes into a
machine&#8217;s configuration.</p>
</li>
<li>
<p>Contents: Because the bootstrap machine serves the Ignition configs for other
machines, both master and worker machine Ignition config information is stored in the
<code>bootstrap.ign</code>, along with the bootstrap machine&#8217;s configuration.</p>
</li>
<li>
<p>Size: The file is more than 1300 lines long, with path to various types of resources.</p>
</li>
<li>
<p>The content of each file that will be copied to the machine is actually encoded
into data URLs, which tends to make the content a bit clumsy to read. (Use the
  <code>jq</code> and <code>base64</code> commands shown previously to make the content more readable.)</p>
</li>
<li>
<p>Configuration: The different sections of the Ignition config file are generally
meant to contain files that are just dropped into a machine&#8217;s file system, rather
than commands to modify existing files. For example, instead of having a section
on NFS that configures that service, you would just add an NFS configuration
file, which would then be started by the init process when the system comes up.</p>
</li>
<li>
<p>users: A user named <code>core</code> is created, with your SSH key assigned to that user.
This allows you to log in to the cluster with that user name and your
credentials.</p>
</li>
<li>
<p>storage: The storage section identifies files that are added to each machine. A
few notable files include <code>/root/.docker/config.json</code> (which provides credentials
  your cluster needs to pull from container image registries) and a bunch of
  manifest files in <code>/opt/openshift/manifests</code> that are used to configure your cluster.</p>
</li>
<li>
<p>systemd: The <code>systemd</code> section holds content used to create <code>systemd</code> unit files.
Those files are used to start up services at boot time, as well as manage those
services on running systems.</p>
</li>
<li>
<p>Primitives: Ignition also exposes low-level primitives that other tools can
build on.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="digging-into-machine-config_architecture-rhcos"><a class="anchor" href="#digging-into-machine-config_architecture-rhcos"></a>Changing Ignition configs after installation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Machine config pools manage a cluster of nodes and their corresponding machine
configs. Machine configs contain configuration information for a cluster.
To list all machine config pools that are known:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-terminal hljs" data-lang="terminal">$ oc get machineconfigpools</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example output</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-terminal hljs" data-lang="terminal">NAME   CONFIG                                  UPDATED UPDATING DEGRADED
master master-1638c1aea398413bb918e76632f20799 False   False    False
worker worker-2feef4f8288936489a5a832ca8efe953 False   False    False</code></pre>
</div>
</div>
<div class="paragraph">
<p>To list all machine configs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-terminal hljs" data-lang="terminal">$ oc get machineconfig</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example output</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-terminal hljs" data-lang="terminal">NAME                                      GENERATEDBYCONTROLLER   IGNITIONVERSION   CREATED   OSIMAGEURL

00-master                                 4.0.0-0.150.0.0-dirty   3.2.0             16m
00-master-ssh                             4.0.0-0.150.0.0-dirty                     16m
00-worker                                 4.0.0-0.150.0.0-dirty   3.2.0             16m
00-worker-ssh                             4.0.0-0.150.0.0-dirty                     16m
01-master-kubelet                         4.0.0-0.150.0.0-dirty   3.2.0             16m
01-worker-kubelet                         4.0.0-0.150.0.0-dirty   3.2.0             16m
master-1638c1aea398413bb918e76632f20799   4.0.0-0.150.0.0-dirty   3.2.0             16m
worker-2feef4f8288936489a5a832ca8efe953   4.0.0-0.150.0.0-dirty   3.2.0             16m</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Machine Config Operator acts somewhat differently than Ignition when it
comes to applying these machine configs. The machine configs are read in order
(from 00* to 99*). Labels inside the machine configs identify the type of node
each is for (master or worker). If the same file appears in multiple
machine config files, the last one wins. So, for example, any file that appears
in a 99* file would replace the same file that appeared in a 00* file.
The input <code>MachineConfig</code> objects are unioned into a "rendered" <code>MachineConfig</code>
object, which will be used as a target by the operator and is the value you
can see in the machine config pool.</p>
</div>
<div class="paragraph">
<p>To see what files are being managed from a machine config, look for "Path:"
inside a particular <code>MachineConfig</code> object. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-terminal hljs" data-lang="terminal">$ oc describe machineconfigs 01-worker-container-runtime | grep Path:</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example output</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-terminal hljs" data-lang="terminal">            Path:            /etc/containers/registries.conf
            Path:            /etc/containers/storage.conf
            Path:            /etc/crio/crio.conf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be sure to give the machine config file a later name
(such as 10-worker-container-runtime). Keep in mind that the content of each
file is in URL-style data. Then apply the new machine config to the cluster.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
