<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>The OpenShift Container Platform control plane :: Red Hat Docs</title>
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Red Hat Docs</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="rhocp" data-version="4.8">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Red Hat Openshift Container Platform</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">About</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../index.html">Welcome</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../learn_more_about_openshift.html">Learn more about OpenShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../oke_about.html">About OpenShift Kubernetes Engine</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../legal-notice.html">Legal notice</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Release notes</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../release_notes/ocp-4-8-release-notes.html">OpenShift Container Platform 4.8 release notes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../release_notes/versioning-policy.html">Versioning policy</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Architectue</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architecture.html">Product architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architecture-installation.html">Installation and update</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="control-plane.html">The control plane</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="understanding-development.html">Understand OpenShift development</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architecture-rhcos.html">Red Hat Enterprise Linux CoreOS</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="admission-plug-ins.html">Admission plug-ins</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Red Hat Openshift Container Platform</span>
    <span class="version">4.8</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../rhel8/8/index.html">Red Hat Enterprise Linux</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../rhel8/8/index.html">8</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../index.html">Red Hat Openshift Container Platform</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">4.8</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Red Hat Openshift Container Platform</a></li>
    <li>Architectue</li>
    <li><a href="control-plane.html">The control plane</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///Users/ganelson/Documents/alt/openshift-docs/modules/architecture/pages/control-plane.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">The OpenShift Container Platform control plane</h1>
<div class="sect1">
<h2 id="understanding-control-plane_control-plane"><a class="anchor" href="#understanding-control-plane_control-plane"></a>Understanding the OpenShift Container Platform control plane</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The control plane, which is composed of control plane machines (also known as the master machines), manages the
OpenShift Container Platform cluster. The control plane machines manage workloads on the
compute machines, which are also known as worker machines. The cluster itself manages all upgrades to the
machines by the actions of the Cluster Version Operator, the
Machine Config Operator, and a set of individual Operators.</p>
</div>
<div class="sect2">
<h3 id="architecture-machine-config-pools_control-plane"><a class="anchor" href="#architecture-machine-config-pools_control-plane"></a>Node configuration management with machine config pools</h3>
<div class="paragraph">
<p>Machines that run control plane components or user workloads are divided into groups based on the types of resources they handle. These groups of machines are called machine config pools (MCP). Each MCP manages a set of nodes and its corresponding machine configs. The role of the node determines which MCP it belongs to; the MCP governs nodes based on its assigned node role label. Nodes in an MCP have the same configuration; this means nodes can be scaled up and torn down in response to increased or decreased workloads.</p>
</div>
<div class="paragraph">
<p>By default, there are two MCPs created by the cluster when it is installed: <code>master</code> and <code>worker</code>. Each default MCP has a defined configuration applied by the Machine Config Operator (MCO), which is responsible for managing MCPs and facilitating MCP upgrades. You can create additional MCPs, or custom pools, to manage nodes that have custom use cases that extend outside of the default node types.</p>
</div>
<div class="paragraph">
<p>Custom pools are pools that inherit their configurations from the worker pool. They use any machine config targeted for the worker pool, but add the ability to deploy changes only targeted at the custom pool. Since a custom pool inherits its configuration from the worker pool, any change to the worker pool is applied to the custom pool as well. Custom pools that do not inherit their configurations from the worker pool are not supported by the MCO.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A node can only be included in one MCP. If a node has multiple labels that correspond to several MCPs, like <code>worker,infra</code>, it is managed by the infra custom pool, not the worker pool. Custom pools take priority on selecting nodes to manage based on node labels; nodes that do not belong to a custom pool are managed by the worker pool.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is recommended to have a custom pool for every node role you want to manage in your cluster. For example, if you create infra nodes to handle infra workloads, it is recommended to create a custom infra MCP to group those nodes together. If you apply an <code>infra</code> role label to a worker node so it has the <code>worker,infra</code> dual label, but do not have a custom infra MCP, the MCO considers it a worker node. If you remove the <code>worker</code> label from a node and apply the <code>infra</code> label without grouping it in a custom pool, the node is not recognized by the MCO and is unmanaged by the cluster.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Any node labeled with the <code>infra</code> role that is only running infra workloads is not counted toward the total number of subscriptions. The MCP managing an infra node is mutually exclusive from how the cluster determines subscription charges; tagging a node with the appropriate <code>infra</code> role and using taints to prevent user workloads from being scheduled on that node are the only requirements for avoiding subscription charges for infra workloads.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The MCO applies updates for pools independently; for example, if there is an update that affects all pools, nodes from each pool update in parallel with each other. If you add a custom pool, nodes from that pool also attempt to update concurrently with the master and worker nodes.</p>
</div>
</div>
<div class="sect2">
<h3 id="architecture-machine-roles_control-plane"><a class="anchor" href="#architecture-machine-roles_control-plane"></a>Machine roles in OpenShift Container Platform</h3>
<div class="paragraph">
<p>OpenShift Container Platform assigns hosts different roles. These roles define the function of the machine within the cluster. The cluster contains definitions for the standard master and worker role types.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The cluster also contains the definition for the bootstrap role. Because the bootstrap machine is used only during cluster installation, its function is explained in the cluster installation documentation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="defining-workers_control-plane"><a class="anchor" href="#defining-workers_control-plane"></a>Cluster workers</h4>
<div class="paragraph">
<p>In a Kubernetes cluster, the worker nodes are where the actual workloads requested by Kubernetes users run and are managed. The worker nodes advertise their capacity and the scheduler, which is part of the master services, determines on which nodes to start containers and pods. Important services run on each worker node, including CRI-O, which is the container engine, Kubelet, which is the service that accepts and fulfills requests for running and stopping container workloads, and a service proxy, which manages communication for pods across workers.</p>
</div>
<div class="paragraph">
<p>In OpenShift Container Platform, machine sets control the worker machines. Machines with the worker role drive compute workloads that are governed by a specific machine pool that autoscales them. Because OpenShift Container Platform has the capacity to support multiple machine types, the worker machines are classed as <em>compute</em> machines. In this release, the terms <em>worker machine</em> and <em>compute machine</em> are used interchangeably because the only default type of compute machine is the worker machine. In future versions of OpenShift Container Platform, different types of compute machines, such as infrastructure machines, might be used by default.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Machine sets are groupings of machine resources under the <code>machine-api</code> namespace. Machine sets are configurations that are designed to start new machines on a specific cloud provider. Conversely, machine config pools (MCPs) are part of the Machine Config Operator (MCO) namespace. An MCP is used to group machines together so the MCO can manage their configurations and facilitate their upgrades.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="defining-masters_control-plane"><a class="anchor" href="#defining-masters_control-plane"></a>Cluster masters</h4>
<div class="paragraph">
<p>In a Kubernetes cluster, the control plane nodes (also known as the master nodes) run services that are required to control the Kubernetes cluster. In OpenShift Container Platform, the control plane machines are the control plane. They contain more than just the Kubernetes services for managing the OpenShift Container Platform cluster. Because all of the machines with the control plane role are control plane machines, the terms <em>master</em> and <em>control plane</em> are used interchangeably to describe them. Instead of being grouped into a machine set, control plane machines are defined by a series of standalone machine API resources. Extra controls apply to control plane machines to prevent you from deleting all control plane machines and breaking your cluster.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Exactly three control plane nodes must be used for all production deployments.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Services that fall under the Kubernetes category on the master include the Kubernetes API server, etcd, the Kubernetes controller manager, and the Kubernetes scheduler.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Kubernetes services that run on the control plane</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The Kubernetes API server validates and configures the data for pods, services,
and replication controllers. It also provides a focal point for the shared state of the cluster.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">etcd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">etcd stores the persistent master state while other components watch etcd for
changes to bring themselves into the specified state.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes controller manager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The Kubernetes controller manager watches etcd for changes to objects such as
replication, namespace, and service account controller objects, and then uses the
API to enforce the specified state. Several such processes create a cluster with
one active leader at a time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes scheduler</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The Kubernetes scheduler watches for newly created pods without an assigned node and selects the best node to host the pod.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>There are also OpenShift services that run on the control plane, which include the OpenShift API server, OpenShift controller manager, OpenShift OAuth API server, and OpenShift OAuth server.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. OpenShift services that run on the control plane</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenShift API server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The OpenShift API server validates and configures the data for OpenShift resources, such as projects, routes, and templates.</p>
<p class="tableblock">The OpenShift API server is managed by the OpenShift API Server Operator.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenShift controller manager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The OpenShift controller manager watches etcd for changes to OpenShift objects, such as project, route, and template controller objects, and then uses the API to enforce the specified state.</p>
<p class="tableblock">The OpenShift controller manager is managed by the OpenShift Controller Manager Operator.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenShift OAuth API server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The OpenShift OAuth API server validates and configures the data to authenticate to OpenShift Container Platform, such as users, groups, and OAuth tokens.</p>
<p class="tableblock">The OpenShift OAuth API server is managed by the Cluster Authentication Operator.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenShift OAuth server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Users request tokens from the OpenShift OAuth server to authenticate themselves to the API.</p>
<p class="tableblock">The OpenShift OAuth server is managed by the Cluster Authentication Operator.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Some of these services on the control plane machines run as systemd services, while others run as static pods.</p>
</div>
<div class="paragraph">
<p>Systemd services are appropriate for services that you need to always come up on that particular system shortly after it starts. For control plane machines, those include sshd, which allows remote login. It also includes services such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The CRI-O container engine (crio), which runs and manages the containers. OpenShift Container Platform 4.8 uses CRI-O instead of the Docker Container Engine.</p>
</li>
<li>
<p>Kubelet (kubelet), which accepts requests for managing containers on the machine from master services.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>CRI-O and Kubelet must run directly on the host as systemd services because they need to be running before you can run other containers.</p>
</div>
<div class="paragraph">
<p>The <code>installer-*</code> and <code>revision-pruner-*</code> control plane pods must run with root permissions because they write to the <code>/etc/kubernetes</code> directory, which is owned by the root user. These pods are in the following namespaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>openshift-etcd</code></p>
</li>
<li>
<p><code>openshift-kube-apiserver</code></p>
</li>
<li>
<p><code>openshift-kube-controller-manager</code></p>
</li>
<li>
<p><code>openshift-kube-scheduler</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="operators-overview_control-plane"><a class="anchor" href="#operators-overview_control-plane"></a>Operators in OpenShift Container Platform</h3>
<div class="paragraph">
<p>In OpenShift Container Platform, Operators are the preferred method of packaging, deploying,
and managing services on the control plane. They also provide advantages to
applications that users run. Operators integrate with
Kubernetes APIs and CLI tools such as <code>kubectl</code> and <code>oc</code> commands. They provide
the means of watching over an application, performing health checks, managing
over-the-air updates, and ensuring that the applications remain in your
specified state.</p>
</div>
<div class="paragraph">
<p>Because CRI-O and the Kubelet run on every node, almost every other cluster
function can be managed on the control plane by using Operators. Operators are
among the most important components of OpenShift Container Platform 4.8.
Components that are added to the control plane by using Operators include
critical networking and credential services.</p>
</div>
<div class="paragraph">
<p>The Operator that manages the other Operators in an OpenShift Container Platform cluster is
the Cluster Version Operator.</p>
</div>
<div class="paragraph">
<p>OpenShift Container Platform 4.8 uses different classes of Operators to perform
cluster operations and run services on the cluster for your applications to use.</p>
</div>
<div class="sect3">
<h4 id="OLM-operators_control-plane"><a class="anchor" href="#OLM-operators_control-plane"></a>Operators managed by OLM</h4>
<div class="paragraph">
<p>The Cluster Operator Lifecycle Management (OLM) component manages Operators
that are available for use in applications. It does not manage the Operators that
comprise OpenShift Container Platform.
OLM is a framework that manages Kubernetes-native applications as Operators.
Instead of managing Kubernetes manifests, it manages Kubernetes Operators.
OLM manages two classes of Operators, Red Hat Operators and certified Operators.</p>
</div>
<div class="paragraph">
<p>Some Red Hat Operators drive the cluster functions, like the scheduler and
problem detectors. Others are provided for you to manage yourself and use in
your applications, like etcd. OpenShift Container Platform also offers certified Operators,
which the community built and maintains. These certified Operators provide an
API layer to traditional applications so you can manage the application through
Kubernetes constructs.</p>
</div>
</div>
<div class="sect3">
<h4 id="update-service-overview_control-plane"><a class="anchor" href="#update-service-overview_control-plane"></a>About the OpenShift Update Service</h4>
<div class="paragraph">
<p>The OpenShift Update Service (OSUS) provides over-the-air updates to OpenShift Container Platform, including Red Hat Enterprise Linux CoreOS (RHCOS). It provides a graph, or diagram, that contains the <em>vertices</em> of component Operators and the <em>edges</em> that connect them. The edges in the graph show which versions you can safely update to. The vertices are update payloads that specify the intended state of the managed cluster components.</p>
</div>
<div class="paragraph">
<p>The Cluster Version Operator (CVO) in your cluster checks with the OpenShift Update Service to see the valid updates and update paths based on current component versions and information in the graph. When you request an update, the CVO uses the release image for that update to upgrade your cluster. The release artifacts are hosted in Quay as container images.</p>
</div>
<div class="paragraph">
<p>To allow the OpenShift Update Service to provide only compatible updates, a release verification pipeline drives automation. Each release artifact is verified for compatibility with supported cloud platforms and system architectures, as well as other component packages. After the pipeline confirms the suitability of a release, the OpenShift Update Service notifies you that it is available.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The OpenShift Update Service displays all valid updates. Do not force an update to a version that the OpenShift Update Service does not display.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Two controllers run during continuous update mode. The first controller continuously updates the payload manifests, applies the manifests to the cluster, and outputs the controlled rollout status of the Operators to indicate whether they are available, upgrading, or failed. The second controller polls the OpenShift Update Service to determine if updates are available.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Only upgrading to a newer version is supported. Reverting or rolling back your cluster to a previous version is not supported. If your upgrade fails, contact Red Hat support.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>During the upgrade process, the Machine Config Operator (MCO) applies the new configuration to your cluster machines. The MCO cordons the number of nodes as specified by the <code>maxUnavailable</code> field on the machine configuration pool and marks them as unavailable. By default, this value is set to <code>1</code>. The MCO then applies the new configuration and reboots the machine.</p>
</div>
<div class="paragraph">
<p>If you use Red Hat Enterprise Linux (RHEL) machines as workers, the MCO does not update the kubelet because you must update the OpenShift API on the machines first.</p>
</div>
<div class="paragraph">
<p>With the specification for the new version applied to the old kubelet, the RHEL machine cannot return to the <code>Ready</code> state. You cannot complete the update until the machines are available. However, the maximum number of unavailable nodes is set to ensure that normal cluster operations can continue with that number of machines out of service.</p>
</div>
<div class="paragraph">
<p>The OpenShift Update Service is composed of an Operator and one or more application instances.</p>
</div>
</div>
<div class="sect3">
<h4 id="understanding-machine-config-operator_control-plane"><a class="anchor" href="#understanding-machine-config-operator_control-plane"></a>Understanding the Machine Config Operator</h4>
<div class="paragraph">
<p>OpenShift Container Platform 4.8 integrates both
operating system and cluster management. Because the cluster manages its own
updates, including updates to Red Hat Enterprise Linux CoreOS (RHCOS) on cluster nodes,
OpenShift Container Platform provides an opinionated lifecycle management
experience that simplifies the orchestration of node upgrades.</p>
</div>
<div class="paragraph">
<p>OpenShift Container Platform employs three daemon sets and controllers to
simplify node management. These daemon sets orchestrate operating system updates
and configuration changes to the hosts by using standard Kubernetes-style
constructs. They include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>machine-config-controller</code>, which coordinates machine upgrades from the control
plane. It monitors all of the cluster nodes and orchestrates their configuration
updates.</p>
</li>
<li>
<p>The <code>machine-config-daemon</code> daemon set, which runs on
each node in the cluster and updates a machine to configuration as defined by
machine config and as instructed by the MachineConfigController. When the node detects
a change, it drains off its pods, applies the update, and reboots. These changes
come in the form of Ignition configuration files that apply the specified
machine configuration and control kubelet configuration. The update itself is
delivered in a container. This process is key to the success of managing
OpenShift Container Platform and RHCOS updates together.</p>
</li>
<li>
<p>The <code>machine-config-server</code> daemon set, which provides the Ignition config files
to control plane nodes as they join the cluster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The machine configuration is a subset of the Ignition configuration. The
<code>machine-config-daemon</code> reads the machine configuration to see if it needs to do
an OSTree update or if it must apply a series of systemd kubelet file changes,
configuration changes, or other changes to the operating system or OpenShift Container Platform
configuration.</p>
</div>
<div class="paragraph">
<p>When you perform node management operations, you create or modify a
<code>KubeletConfig</code> custom resource (CR).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When changes are made to a machine configuration, the Machine Config Operator (MCO) automatically reboots all corresponding nodes in order for the changes to take effect.</p>
</div>
<div class="paragraph">
<p>To prevent the nodes from automatically rebooting after machine configuration changes, before making the changes, you must pause the autoreboot process by setting the <code>spec.paused</code> field to <code>true</code> in the corresponding machine config pool. When paused, machine configuration changes are not applied until you set the <code>spec.paused</code> field to <code>false</code> and the nodes have rebooted into the new configuration.</p>
</div>
<div class="paragraph">
<p>The following modifications do not trigger a node reboot:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the MCO detects any of the following changes, it applies the update without draining or rebooting the node:</p>
<div class="ulist">
<ul>
<li>
<p>Changes to the SSH key in the <code>spec.config.ignition.passwd.users.sshAuthorizedKeys</code> parameter of a machine config.</p>
</li>
<li>
<p>Changes to the global pull secret or pull secret in the <code>openshift-config</code> namespace.</p>
</li>
<li>
<p>Automatic rotation of the <code>/etc/kubernetes/kubelet-ca.crt</code> certificate authority (CA) by the Kubernetes API Server Operator.</p>
</li>
</ul>
</div>
</li>
<li>
<p>When the MCO detects changes to the <code>/etc/containers/registries.conf</code> file, such as adding or editing an <code>ImageContentSourcePolicy</code> object, it drains the corresponding nodes, applies the changes, and uncordons the nodes.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">Additional information</div>
<p>For information on preventing the control plane machines from rebooting after the Machine Config Operator makes changes to the machine config, see <a href="#../support/troubleshooting/troubleshooting-operator-issues.adoc#troubleshooting-disabling-autoreboot-mco_troubleshooting-operator-issues" class="page unresolved">Disabling Machine Config Operator from automatically rebooting</a>.</p>
</div>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
